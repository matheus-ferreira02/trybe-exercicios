{"ast":null,"code":"var _jsxFileName = \"/home/matheus_totoso/primeiros-passos-redux/src/components/SecondComponent.js\";\nimport React from 'react';\nimport { connect } from 'react-redux';\nimport { newAction } from './actions'; // Import referente a `action creator` criada para disparar a ação para a store.\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nclass SecondComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      inputValue: ''\n    }; // Esse estado irá armazenar o valor do input\n  }\n\n  render() {\n    const {\n      myFirstDispatch\n    } = this.props;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: [/*#__PURE__*/_jsxDEV(\"input\", {\n        type: \"text\",\n        onChange: event => this.setState({\n          inputValue: event.target.value\n        })\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 17,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => this.props.myFirstDispatch(this.state.inputValue),\n        children: \" / Executar qualquer tarefa\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 21,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 16,\n      columnNumber: 7\n    }, this);\n  }\n\n} // utilizando `action`:\n// const mapDispatchToProps = (dispatch) => ({\n// myFirstDispatch: (state) => dispatch({ type: 'NEW_ACTION', state }),\n// });\n// No caso acima, vemos que o mapDispatchToProps é uma função que retorna um objeto, e sua key recebe uma callback.\n// Essa callback terá um parâmetro correspondente ao estado que será enviado para a store.\n// Nessa callback, chamamos a função `dispatch`, que receberá como argumento a `action`,\n// que é um objeto contendo o \"type\" e o parametro da callback, o \"state\", que será o novo valor do estado.\n// utilizando `action creator `:\n\n\nconst mapDispatchToProps = dispatch => ({\n  myFirstDispatch: state => dispatch(newAction(state))\n}); // Podemos utilizar o mapDispatchToProps de outra forma também! Lembra do arquivo que foi criado contendo a função \"newAction?\n// No exemplo acima, o dispatch está recebendo como argumento a \"newAction\", que também é chamada de `action creator`.\n// E é aí que está a vantagem de utilizar  as `action creator`, pois elas também geram uma `action`.\n\n\nexport default connect(null, mapDispatchToProps)(SecondComponent);","map":{"version":3,"sources":["/home/matheus_totoso/primeiros-passos-redux/src/components/SecondComponent.js"],"names":["React","connect","newAction","SecondComponent","Component","constructor","props","state","inputValue","render","myFirstDispatch","event","setState","target","value","mapDispatchToProps","dispatch"],"mappings":";AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,SAASC,OAAT,QAAwB,aAAxB;AACA,SAASC,SAAT,QAA0B,WAA1B,C,CACA;;;;AAEA,MAAMC,eAAN,SAA8BH,KAAK,CAACI,SAApC,CAA8C;AAC5CC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,UAAMA,KAAN;AACA,SAAKC,KAAL,GAAa;AAAEC,MAAAA,UAAU,EAAE;AAAd,KAAb,CAFiB,CAGjB;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACP,UAAM;AAAEC,MAAAA;AAAF,QAAsB,KAAKJ,KAAjC;AACA,wBACE;AAAA,8BACE;AACE,QAAA,IAAI,EAAC,MADP;AAEE,QAAA,QAAQ,EAAEK,KAAK,IAAI,KAAKC,QAAL,CAAc;AAAEJ,UAAAA,UAAU,EAAEG,KAAK,CAACE,MAAN,CAAaC;AAA3B,SAAd;AAFrB;AAAA;AAAA;AAAA;AAAA,cADF,eAKE;AAAQ,QAAA,OAAO,EAAE,MAAM,KAAKR,KAAL,CAAWI,eAAX,CAA2B,KAAKH,KAAL,CAAWC,UAAtC,CAAvB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,cALF;AAAA;AAAA;AAAA;AAAA;AAAA,YADF;AAWD;;AApB2C,C,CAuB9C;AACA;AACE;AACF;AAEA;AACA;AACA;AACA;AAGA;;;AAEA,MAAMO,kBAAkB,GAAIC,QAAD,KAAe;AACxCN,EAAAA,eAAe,EAAGH,KAAD,IAAWS,QAAQ,CAACd,SAAS,CAACK,KAAD,CAAV;AADI,CAAf,CAA3B,C,CAGA;AACA;AACA;;;AAEA,eAAeN,OAAO,CAAC,IAAD,EAAOc,kBAAP,CAAP,CAAkCZ,eAAlC,CAAf","sourcesContent":["import React from 'react';\nimport { connect } from 'react-redux';\nimport { newAction } from './actions';\n// Import referente a `action creator` criada para disparar a ação para a store.\n\nclass SecondComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { inputValue: '' };\n    // Esse estado irá armazenar o valor do input\n  }\n\n  render() {\n    const { myFirstDispatch } = this.props\n    return (\n      <div>\n        <input\n          type=\"text\"\n          onChange={event => this.setState({ inputValue: event.target.value })}\n        />\n        <button onClick={() => this.props.myFirstDispatch(this.state.inputValue)}> /\n          Executar qualquer tarefa\n        </button>\n      </div>\n    );\n  }\n}\n\n// utilizando `action`:\n// const mapDispatchToProps = (dispatch) => ({\n  // myFirstDispatch: (state) => dispatch({ type: 'NEW_ACTION', state }),\n// });\n\n// No caso acima, vemos que o mapDispatchToProps é uma função que retorna um objeto, e sua key recebe uma callback.\n// Essa callback terá um parâmetro correspondente ao estado que será enviado para a store.\n// Nessa callback, chamamos a função `dispatch`, que receberá como argumento a `action`,\n// que é um objeto contendo o \"type\" e o parametro da callback, o \"state\", que será o novo valor do estado.\n\n\n// utilizando `action creator `:\n\nconst mapDispatchToProps = (dispatch) => ({\n  myFirstDispatch: (state) => dispatch(newAction(state))});\n\n// Podemos utilizar o mapDispatchToProps de outra forma também! Lembra do arquivo que foi criado contendo a função \"newAction?\n// No exemplo acima, o dispatch está recebendo como argumento a \"newAction\", que também é chamada de `action creator`.\n// E é aí que está a vantagem de utilizar  as `action creator`, pois elas também geram uma `action`.\n\nexport default connect(null, mapDispatchToProps)(SecondComponent);"]},"metadata":{},"sourceType":"module"}